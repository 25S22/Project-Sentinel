In one terminal, run this command to start monitoring the system logs specifically for the yes process:

Bash

journalctl -f -o json | grep '"SYSLOG_IDENTIFIER":"yes"'
Your cursor will just sit there, waiting for new logs. That's normal.

In a second terminal, start the yes command:

Bash

yes "testing the logs" > /dev/null &

import google.generativeai as genai
import os
import sys
import socket
import iptc
import vt
import json
import time
import threading
from datetime import datetime
from urllib.parse import urlparse
import numpy as np
import pandas as pd
import tensorflow as tf
from sklearn.preprocessing import StandardScaler
from sklearn.feature_extraction import FeatureHasher
import joblib
import re
import csv
import subprocess

# --- CONFIGURATION ---
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
VT_API_KEY = os.getenv("VT_API_KEY")
LOG_FILE_PATH = "sentinel_audit.log"
SURICATA_LOG_PATH = "/var/log/suricata/eve.json"

# --- ANOMALY DETECTION FILE PATHS ---
ANOMALY_MODEL_PATH = "lstm_autoencoder.keras"
SCALER_PATH = "scaler.gz"
HASHER_PATH = "hasher.gz"
THRESHOLD_PATH = "threshold.txt"

# --- ANOMALY DETECTION PARAMETERS (must match training) ---
ANOMALY_TIMESTEPS = 10
ANOMALY_N_FEATURES = 5

SYSTEM_LOG_SOURCE = ['journalctl', '-f', '-o', 'json']

# --- API KEY VALIDATION ---
if not GEMINI_API_KEY:
    raise ValueError("GEMINI_API_KEY not found. Please set the environment variable. If using sudo, try 'sudo -E'.")
if not VT_API_KEY:
    raise ValueError("VT_API_KEY not found. Please set it as an environment variable. If using sudo, try 'sudo -E'.")

genai.configure(api_key=GEMINI_API_KEY)
model = genai.GenerativeModel('gemini-1.5-flash')

# --- Global variables for the anomaly detection components ---
anomaly_model = None
anomaly_scaler = None
anomaly_hasher = None
anomaly_threshold = 0.0

# --- HELPER FUNCTIONS ---

def log_event(data):
    """Appends a JSON object with a timestamp to the audit log file."""
    try:
        with open(LOG_FILE_PATH, 'a') as log_file:
            log_entry = {"timestamp": datetime.now().isoformat(), "event_data": data}
            log_file.write(json.dumps(log_entry) + '\n')
    except Exception as e:
        print(f"\nSentinel: [ERROR] Failed to write to log file: {e}")

def get_generative_analysis(prompt):
    """Sends a prompt to the AI model and returns the text response."""
    try:
        response = model.generate_content(prompt)
        return response.text
    except Exception as e:
        return f"[Analysis Error: Could not process request. Reason: {e}]"

def verify_rule_exists(ip_to_check):
    """Reads the live firewall rules to confirm if a block for the IP exists."""
    try:
        table = iptc.Table(iptc.Table.FILTER)
        table.refresh()
        chain = iptc.Chain(table, "INPUT")
        for rule in chain.rules:
            if rule.src and ip_to_check in rule.src:
                return True
        return False
    except Exception as e:
        print(f"\nSentinel: [VERIFICATION ERROR] Could not read iptables rules: {e}")
        return False

# --- ANALYSIS & BLOCKING LOGIC ---

def investigate_indicator(indicator, source="MANUAL_INPUT"):
    """
    Central function to investigate an IP or URL.
    This function performs the OSINT and AI analysis.
    """
    print(f"\n\n--- [ NEW INVESTIGATION ] ---")
    print(f"Source: {source}")
    print(f"Indicator: {indicator}")
    
    # --- VIRUSTOTAL CHECK ---
    print(f"\nSentinel: Conducting OSINT on {indicator} via VirusTotal...")
    vt_result = check_virustotal_indicator(indicator)
    log_event(vt_result)

    if vt_result["status"] == "error":
        print(f"Sentinel: [ERROR] OSINT failed. Reason: {vt_result['message']}")
        return None, None
    
    malicious_count = vt_result['malicious_vendors']
    print(f"Sentinel: OSINT complete. VirusTotal reports {malicious_count} malicious detections.")

    # --- GENERATIVE ANALYSIS ---
    print(f"\nSentinel: Performing generative analysis...")
    if malicious_count > 0:
        analysis_prompt = f"Analyze the indicator '{indicator}'.\n\n1. **Overview:** Briefly describe its identity (e.g., website purpose, IP owner).\n\n2. **Threat Analysis:** It was flagged with {malicious_count} malicious detections. Detail the likely threats (phishing, malware, scam, etc.) and risks."
    else:
        analysis_prompt = f"Analyze the indicator '{indicator}'.\n\n1. **Detailed Overview:** Provide a detailed overview of the website or IP owner.\n\n2. **Security Reputation:** Conclude with its security reputation, noting it was not flagged by scanners."
    
    analysis_text = get_generative_analysis(analysis_prompt)
    print("\n--- Generative Analysis ---")
    print(analysis_text)
    print("---------------------------")
    print(f"--- [ END INVESTIGATION ] ---\n")
    
    return malicious_count, indicator

def check_virustotal_indicator(indicator):
    """Wrapper to handle both URLs and IPs for VirusTotal."""
    is_ip = all(c in "0123456789." for c in indicator)

    try:
        with vt.Client(VT_API_KEY) as client:
            if is_ip:
                result_obj = client.get_object(f"/ip_addresses/{indicator}")
            else:
                url_id = vt.url_id(indicator)
                result_obj = client.get_object(f"/urls/{url_id}")
            
            stats = result_obj.last_analysis_stats
            malicious_votes = stats.get('malicious', 0)
            return {"indicator": indicator, "status": "completed", "malicious_vendors": malicious_votes}
    except Exception as e:
        return {"indicator": indicator, "status": "error", "message": str(e)}

def block_indicator(indicator):
    """Handles the logic to block a given indicator (URL or IP)."""
    try:
        is_ip = all(c in "0123456789." for c in indicator)
        if not is_ip:
            hostname = urlparse(f'//{indicator}' if '://' not in indicator else indicator).hostname
            ip_to_block = socket.gethostbyname(hostname)
        else:
            ip_to_block = indicator

        print(f"Sentinel: Attempting to apply firewall block for IP: {ip_to_block}...")
        table = iptc.Table(iptc.Table.FILTER)
        chain = iptc.Chain(table, "INPUT")
        rule = iptc.Rule()
        rule.src = ip_to_block
        rule.target = chain.create_target("DROP")
        chain.insert_rule(rule)
        table.commit()
        table.refresh()

        print("Sentinel: Verifying block implementation...")
        if verify_rule_exists(ip_to_block):
            success_message = f"VERIFICATION SUCCESS: Firewall rule for {ip_to_block} is active."
            print(f"Sentinel: {success_message}")
            log_event({"action": "BLOCK_IP_VERIFIED", "details": success_message})
        else:
            failure_message = f"VERIFICATION FAILED: Rule for {ip_to_block} was NOT added."
            print(f"Sentinel: {failure_message}")
            log_event({"action": "BLOCK_IP_FAILED", "details": failure_message})

    except Exception as e:
        error_message = f"An unexpected error occurred during the block action: {e}"
        print(f"Sentinel: [ERROR] {error_message}")
        log_event({"action": "BLOCK_IP_EXCEPTION", "details": error_message})

# --- PROACTIVE MONITORING THREADS ---

def run_suricata_monitor():
    """Monitors the Suricata log file for new alerts in a separate thread."""
    print("Sentinel: Suricata monitoring thread started. Watching logs...")
    try:
        with open(SURICATA_LOG_PATH, 'r') as log_file:
            log_file.seek(0, 2)
            while True:
                new_line = log_file.readline()
                if new_line:
                    try:
                        alert = json.loads(new_line)
                        if alert.get('event_type') == 'alert':
                            src_ip = alert.get('src_ip')
                            signature = alert.get('alert', {}).get('signature')
                            print(f"\nSentinel: [SURICATA ALERT] Detected: {signature} from {src_ip}")
                            investigate_indicator(src_ip, source=f"SURICATA: {signature}")
                    except json.JSONDecodeError:
                        continue
                else:
                    time.sleep(1)
    except FileNotFoundError:
        print(f"Sentinel: [MONITOR ERROR] Suricata log not found at {SURICATA_LOG_PATH}. Suricata monitor is disabled.")
    except Exception as e:
        print(f"Sentinel: [MONITOR ERROR] An unexpected error occurred in Suricata monitor: {e}")

def run_anomaly_monitor():
    """Monitors system logs for anomalies using the trained LSTM Autoencoder."""
    global anomaly_model, anomaly_scaler, anomaly_hasher, anomaly_threshold

    if not all([anomaly_model, anomaly_scaler, anomaly_hasher]):
        print("Sentinel: [ANOMALY MONITOR ERROR] Anomaly detection components not fully loaded. Monitor disabled.")
        return

    print("Sentinel: Anomaly monitoring thread started. Watching system logs for unusual behavior...")
    
    current_sequence_features = []
    process = None
    try:
        process = subprocess.Popen(SYSTEM_LOG_SOURCE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        
        for line in iter(process.stdout.readline, ''):
            if line:
                try:
                    log_entry = json.loads(line)
                    process_name = log_entry.get('SYSLOG_IDENTIFIER', 'UNKNOWN').strip()
                    
                    if process_name and process_name != 'UNKNOWN':
                        # <<< --- START DEBUG PRINT 1 --- >>>
                        print(f"  [Debug] Processing log: {process_name}")
                        # <<< --- END DEBUG PRINT 1 --- >>>
                        
                        hashed_feature = anomaly_hasher.transform([[process_name]]).toarray()
                        scaled_feature = anomaly_scaler.transform(hashed_feature)
                        
                        current_sequence_features.append(scaled_feature[0])

                        if len(current_sequence_features) > ANOMALY_TIMESTEPS:
                            current_sequence_features.pop(0)

                        if len(current_sequence_features) == ANOMALY_TIMESTEPS:
                            sequence_np = np.array(current_sequence_features).reshape(1, ANOMALY_TIMESTEPS, ANOMALY_N_FEATURES)
                            
                            reconstruction = anomaly_model.predict(sequence_np, verbose=0)
                            mae_loss = np.mean(np.abs(reconstruction - sequence_np))

                            # <<< --- START DEBUG PRINT 2 --- >>>
                            print(f"  [Debug] Loss: {mae_loss:.6f} | Threshold: {anomaly_threshold:.6f}")
                            # <<< --- END DEBUG PRINT 2 --- >>>

                            if mae_loss > anomaly_threshold:
                                print(f"\nSentinel: [ANOMALY DETECTED] Reconstruction Error: {mae_loss:.4f} > Threshold: {anomaly_threshold:.4f}")
                                investigation_prompt = f"Investigate a security anomaly in system logs. Reconstruction error is {mae_loss:.4f}, exceeding the normal behavior threshold. The last observed process was '{process_name}'. Analyze potential threats like unauthorized access, malware execution, or privilege escalation. What could be happening?"
                                genai_analysis = get_generative_analysis(investigation_prompt)
                                print("\n--- Anomaly Generative Analysis ---")
                                print(genai_analysis)
                                print("-----------------------------------")
                                log_event({"action": "ANOMALY_DETECTED", "loss": mae_loss, "threshold": anomaly_threshold, "details": genai_analysis, "last_process": process_name})
                                
                except json.JSONDecodeError:
                    continue
                except Exception as e:
                    print(f"Sentinel: [ANOMALY MONITOR ERROR] Error processing log line: {e}")
            else:
                time.sleep(0.1)
    except FileNotFoundError:
        print("[ANOMALY MONITOR ERROR] 'journalctl' command not found. Anomaly monitor disabled.")
    except Exception as e:
        print(f"Sentinel: [ANOMALY MONITOR ERROR] An unexpected error occurred: {e}")
    finally:
        if process:
            process.terminate()

# --- MAIN APPLICATION & CLI THREAD ---

def run_sentinel_cli():
    """Handles the main command-line interface for user input."""
    print("\nSentinel: Greetings, I am your personal defensive agent. How can I assist you?")
    while True:
        user_input = input("You > ")
        if user_input.lower() in ['exit', 'quit']:
            print("Sentinel: Shutting down.")
            os._exit(0)

        if user_input.lower().startswith("check_reputation"):
            parts = user_input.split()
            if len(parts) < 2:
                print("Sentinel: Please provide a URL or IP. Usage: check_reputation <indicator>")
                continue
            
            indicator_to_check = parts[1]
            malicious_count, indicator = investigate_indicator(indicator_to_check)
            
            if malicious_count is not None and malicious_count > 0:
                confirmation = input("\nSentinel: Threat detected. Would you like to block this indicator? (yes/no) > ")
                if confirmation.lower() == 'yes':
                    block_indicator(indicator)
                else:
                    print("Sentinel: Understood. No action will be taken.")
                    log_event({"action": "USER_DECLINED_BLOCK", "indicator": indicator})
        else:
            print("Sentinel: Processing general query...")
            response_text = get_generative_analysis(user_input)
            print(f"Sentinel: {response_text}")

if __name__ == "__main__":
    try:
        print("Sentinel: Loading anomaly detection model and preprocessors...")
        anomaly_model = tf.keras.models.load_model(ANOMALY_MODEL_PATH, compile=False)
        anomaly_scaler = joblib.load(SCALER_PATH)
        anomaly_hasher = joblib.load(HASHER_PATH)
        with open(THRESHOLD_PATH, 'r') as f:
            anomaly_threshold = float(f.read().strip())
        print(f"Sentinel: Anomaly model and preprocessors loaded. Threshold set to {anomaly_threshold:.4f}.")
    except Exception as e:
        print(f"Sentinel: [ERROR] Failed to load anomaly model or preprocessors: {e}. Anomaly detection will be disabled.")
        anomaly_model = None

    suricata_thread = threading.Thread(target=run_suricata_monitor, daemon=True)
    suricata_thread.start()

    if anomaly_model:
        anomaly_thread = threading.Thread(target=run_anomaly_monitor, daemon=True)
        anomaly_thread.start()

    run_sentinel_cli()
